<!DOCTYPE html>
<html>
<head>
    <title>Mandelbrot Fractal Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background-color: #000;
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
        }
        button {
            padding: 8px 16px;
            margin: 0 5px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>
    <canvas id="FractalCanvas" width="900" height="600"></canvas>
    <div class="controls">
        <button onclick="resetView()">Reset View</button>
    </div>
    <script>
        var element = document.getElementById('FractalCanvas');
        var ctx = element.getContext('2d');
        var topLeft = new bound(new CNum(-2, -1), new Coord(0,0));
        var bottomRight = new bound(new CNum(1, 1), null);
        var mouseDownCoord, mouseUpCoord, mousePressed = false;
        var colour = new RGB(0.2*255,0.9*99,0.3*71);
        var portionOfScreen = 0.4;
        var imgData;
        var minIterations;

        //Hard coded due to Javascript being crap
        var width = Math.round(portionOfScreen * screen.height) * 3;
        var height = Math.round(portionOfScreen * screen.height) * 2;
        var heightWidthRatio = height / width;
        var set = new TwoDArray(width, height);

        window.onload = initialise();

        function initialise() {
            minIterations = 255;
            element.height = height;
            element.width = width;

            calculateSet(set);
            drawSet(0, 0, width, height);
        }

        function resetView() {
            topLeft = new bound(new CNum(-2, -1), new Coord(0,0));
            bottomRight = new bound(new CNum(1, 1), null);
            initialise();
        }

        function bound(axis, coord) {
            this.axis = axis;
            this.coord = coord;
        }

        function CNum(Re, Im){
            this.Re = Re;
            this.Im = Im;
        }

        function Coord(x, y){
            this.x = x;
            this.y = y;
        }

        function TwoDArray(x, y) {
            var a = new Array(x);
            for(var i = 0; i < x; i++){
                a[i] = new Array(y);
            }
            return a;
        }

        FractalCanvas.onmousedown = function(e){
            mouseDownCoord = new Coord(e.clientX - element.offsetLeft, e.clientY - element.offsetTop);
            mousePressed = true;
        }

        FractalCanvas.onmousemove = function(e){
            if (mousePressed) {
                mouseUpCoord = new Coord(e.clientX - element.offsetLeft, e.clientY - element.offsetTop);

                ctx.putImageData(imgData,0,0);

                var xDiff = (mouseUpCoord.x - mouseDownCoord.x) + 1;
                var yDiff = (mouseUpCoord.y - mouseDownCoord.y);
                if ((yDiff / xDiff) < heightWidthRatio) {
                    xDiff = yDiff / heightWidthRatio;
                    mouseUpCoord.x = mouseDownCoord.x + xDiff;
                } else {
                    yDiff = heightWidthRatio * xDiff;
                    mouseUpCoord.y = mouseDownCoord.y + yDiff;
                }

                ctx.fillStyle="gray";
                ctx.fillRect(mouseDownCoord.x, mouseDownCoord.y, xDiff, yDiff);
                mouseUpCoord.x = mouseDownCoord.x + xDiff;
                mouseUpCoord.y = mouseDownCoord.y + yDiff;

                ctx.globalAlpha=0.2;
                ctx.stroke();
            }
        }

        FractalCanvas.onmouseup = function(e){
            mousePressed = false;

            if (mouseUpCoord.y < mouseDownCoord.y) {
                var tempSwap = mouseDownCoord;
                mouseDownCoord = mouseUpCoord;
                mouseUpCoord = tempSwap;
            }

            var temptopLeft = new bound(coordinatesToAxis(mouseDownCoord), mouseDownCoord);
            var tempbottomRight = new bound(coordinatesToAxis(mouseUpCoord), mouseUpCoord);

            topLeft = temptopLeft;
            bottomRight = tempbottomRight;

            initialise();
        }

        function drawSet(xStart, yStart, xEnd, yEnd){
            imgData = ctx.createImageData(xEnd,yEnd);
            var i = 0;
            var dampener = 3.3;

            for(var y = yStart; y < set[0].length; y++){
                for(var x = xStart; x < set.length; x ++){
                    set[x][y] = stretchColour(set[x][y]);
                    imgData.data[4*i+0]=Math.round((colour.red / 255)*set[x][y] * dampener);
                    imgData.data[4*i+1]=Math.round((colour.green / 255)*set[x][y] * dampener);
                    imgData.data[4*i+2]=Math.round((colour.blue / 255)*set[x][y] * dampener);
                    imgData.data[4*i+3]=200;
                    i++;
                }
            }
            ctx.putImageData(imgData,xStart,yStart);
        }

        function stretchColour(val) {
            return (val - minIterations) / (1 - (minIterations / 255));
        }

        function RGB(red, green, blue) {
            this.red = red;
            this.green = green;
            this.blue = blue;
        }

        function coordinatesToAxis(coordinates){
            var scale = width / (bottomRight.axis.Re - topLeft.axis.Re);
            return(new CNum((coordinates.x / scale) + topLeft.axis.Re,
                          (coordinates.y / scale) + topLeft.axis.Im));
        }

        function calculateSet() {
            var tempCoord, tempCNum;
            for (var x = 0; x < set.length; x++) {
                for (var y = 0; y < set[0].length; y++) {
                    tempCoord = new Coord(x, y);
                    tempCNum = coordinatesToAxis(tempCoord);
                    set[x][y] = iterate(tempCNum);
                    if (set[x][y] < minIterations) {
                        minIterations = set[x][y];
                    }
                }
            }
            return set;
        }

        function iterate(c) {
            var tempZ = new CNum(0,0), Z = new CNum(0,0);
            var valueLimit = 4, iterations = 0, iterationLimit = 255;
            while((Z.Re*Z.Re+Z.Im*Z.Im) < valueLimit && iterations < iterationLimit){
                tempZ.Re = Z.Re * Z.Re - Z.Im * Z.Im + c.Re
                tempZ.Im = 2 * Z.Re * Z.Im + c.Im

                Z.Re = tempZ.Re
                Z.Im = tempZ.Im
                iterations++
            }
            return iterations;
        }
    </script>
</body>
</html> 